<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PCA Viewer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: system-ui, sans-serif; background: #fff; height: 100vh; }
        
        .container { display: flex; flex-direction: column; height: 100vh; }
        .header { 
            background: #2d3748; color: white; padding: 10px 15px; 
            border-bottom: 1px solid #ccc; font-size: 14px;
        }
        
        .content { display: flex; flex: 1; overflow: hidden; }
        .sidebar { width: 150px; background: #f5f5f5; border-right: 1px solid #ccc; padding: 10px; overflow-y: auto; }
        .main { flex: 1; display: flex; flex-direction: column; }
        #plot { flex: 1; }
        
        .section { margin-bottom: 12px; }
        .section-label { font-size: 11px; font-weight: bold; color: #333; margin-bottom: 4px; text-transform: uppercase; }
        
        input[type="file"], select { width: 100%; padding: 5px; font-size: 11px; margin-bottom: 6px; border: 1px solid #999; }
        button { width: 100%; padding: 5px; font-size: 11px; background: #667eea; color: white; border: none; cursor: pointer; margin-bottom: 4px; }
        button:hover { background: #764ba2; }
        
        .group-item { display: flex; align-items: center; gap: 6px; padding: 4px; margin-bottom: 3px; font-size: 11px; }
        .group-item input[type="checkbox"] { width: 14px; height: 14px; cursor: pointer; }
        .color-box { width: 12px; height: 12px; border: 1px solid #999; flex-shrink: 0; }
        .group-item label { cursor: pointer; flex: 1; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">PCA Viewer</div>
        
        <div class="content">
            <div class="sidebar">
                <div class="section">
                    <div class="section-label">File</div>
                    <input type="file" id="csvInput" accept=".csv,.eigenvec">
                    <button id="autoLoadBtn">Auto-load</button>
                    <div id="loadStatus" style="font-size: 10px; color: #666; margin-top: 4px;"></div>
                </div>
                
                <div class="section">
                    <div class="section-label">Axes</div>
                    <select id="xAxisSelect"></select>
                    <select id="yAxisSelect"></select>
                </div>
                
                <div class="section">
                    <div class="section-label">Dimension</div>
                    <select id="dimensionSelect">
                        <option value="2d">2D</option>
                        <option value="3d">3D</option>
                    </select>
                    <div id="zAxisContainer" style="display: none;">
                        <select id="zAxisSelect" style="margin-top: 4px;"></select>
                    </div>
                </div>
                
                <div class="section">
                    <div class="section-label">Groups</div>
                    <div id="groupFilters" style="font-size: 11px;"></div>
                </div>
            </div>
            
            <div class="main">
                <div id="plot" style="position: relative;"></div>
            </div>
        </div>
    </div>
    
    <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    
    <script>
    (function() {
        let rawData = [];
        let groupColors = {};
        let availablePCs = [];
        
        const elements = {
            csvInput: document.getElementById('csvInput'),
            autoLoadBtn: document.getElementById('autoLoadBtn'),
            loadStatus: document.getElementById('loadStatus'),
            plot: document.getElementById('plot'),
            groupFilters: document.getElementById('groupFilters'),
            dimensionSelect: document.getElementById('dimensionSelect'),
            xAxisSelect: document.getElementById('xAxisSelect'),
            yAxisSelect: document.getElementById('yAxisSelect'),
            zAxisSelect: document.getElementById('zAxisSelect'),
            zAxisContainer: document.getElementById('zAxisContainer')
        };
        
        const colorPalette = [
            '#667eea', '#764ba2', '#f093fb', '#4facfe',
            '#43e97b', '#fa709a', '#fee140', '#30cfd0',
            '#a8edea', '#fed6e3', '#c471f5', '#fa71cd',
            '#ff6b6b', '#4ecdc4', '#45b7d1', '#f38181'
        ];
        
        const candidatePaths = [
            'pca_data/UZB_final_pca.eigenvec',
            'pca_data/GLOBAL_PCA.eigenvec',
            'UZB_final_pca.eigenvec',
            'GLOBAL_PCA.eigenvec',
            'pca.eigenvec',
            'data/pca.csv'
        ];
        
        function init() {
            Plotly.newPlot(elements.plot, [], {
                margin: { t: 20, l: 50, r: 20, b: 50 },
                xaxis: { title: 'PC1' },
                yaxis: { title: 'PC2' },
                hovermode: 'closest',
                dragmode: 'zoom'
            }, { responsive: true });
            
            elements.csvInput.addEventListener('change', handleFileUpload);
            elements.autoLoadBtn.addEventListener('click', tryAutoLoad);
            elements.dimensionSelect.addEventListener('change', updatePlot);
            elements.xAxisSelect.addEventListener('change', updatePlot);
            elements.yAxisSelect.addEventListener('change', updatePlot);
            elements.zAxisSelect.addEventListener('change', updatePlot);
            
            tryAutoLoad();
        }
        
        async function tryAutoLoad() {
            setStatus('Loading...');
            for (const path of candidatePaths) {
                try {
                    const response = await fetch(path, { cache: 'no-store' });
                    if (response.ok) {
                        const text = await response.text();
                        parseData(text, path);
                        return;
                    }
                } catch (err) {}
            }
            setStatus('No data found. Upload file.');
        }
        
        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => parseData(e.target.result, file.name);
            reader.readAsText(file);
        }
        
        function isEigenvecFormat(text) {
            const lines = text.trim().split('\n');
            if (!lines[0]) return false;
            const firstLine = lines[0].trim();
            if (firstLine.startsWith('#FID') || firstLine.startsWith('FID')) return true;
            
            const cols = firstLine.split(/\s+/);
            return cols.length >= 4 && cols.slice(2).every(col => !isNaN(parseFloat(col)));
        }
        
        function convertEigenvecToCSV(text) {
            const lines = text.trim().split('\n');
            let dataLines = lines;
            
            if (lines[0].startsWith('#FID') || lines[0].startsWith('FID')) {
                dataLines = lines.slice(1);
            }
            
            const firstDataLine = dataLines[0].trim().split(/\s+/);
            const numPCs = firstDataLine.length - 2;
            const pcHeaders = Array.from({length: numPCs}, (_, i) => `pc${i + 1}`).join(',');
            let csv = `fid,iid,${pcHeaders},group\n`;
            
            csv += dataLines.map(line => {
                const cols = line.trim().split(/\s+/);
                const fid = cols[0];
                const iid = cols[1];
                const pcs = cols.slice(2);
                let group = 'UZB';
                if (iid.match(/^HG|^NA/)) group = '1000G';
                return `${fid},${iid},${pcs.join(',')},${group}`;
            }).join('\n');
            
            return csv;
        }
        
        function parseData(csvText, filename) {
            if (filename.endsWith('.eigenvec') || isEigenvecFormat(csvText)) {
                csvText = convertEigenvecToCSV(csvText);
            }
            
            Papa.parse(csvText, {
                header: true,
                skipEmptyLines: true,
                complete: (results) => processData(results.data, filename),
                error: (error) => setStatus('Parse error: ' + error.message)
            });
        }
        
        function processData(data, filename) {
            if (!data || data.length === 0) {
                setStatus('No data found');
                return;
            }
            
            const headers = Object.keys(data[0]);
            const idCol = headers.find(h => h.toLowerCase() === 'iid') || headers[0];
            const pcCols = headers.filter(h => h.toLowerCase().startsWith('pc')).sort();
            
            if (pcCols.length < 2) {
                setStatus('Need at least 2 PCs');
                return;
            }
            
            const groupCol = headers.find(h => h.toLowerCase() === 'group');
            
            rawData = data.map((row, idx) => {
                const point = {
                    __idx: idx,
                    id: String(row[idCol] || `s${idx}`),
                    group: groupCol ? String(row[groupCol]) : 'All',
                    pcs: {}
                };
                
                pcCols.forEach(pc => {
                    const val = parseFloat(row[pc]);
                    if (!isNaN(val)) point.pcs[pc.toLowerCase()] = val;
                });
                
                return point;
            }).filter(p => Object.keys(p.pcs).length >= 2);
            
            availablePCs = pcCols.map(pc => pc.toLowerCase());
            
            const groups = [...new Set(rawData.map(p => p.group))];
            groups.forEach((g, i) => {
                groupColors[g] = colorPalette[i % colorPalette.length];
            });
            
            populatePCSelectors();
            updateGroupFilters();
            updatePlot();
            setStatus(`Loaded ${rawData.length} samples`);
        }
        
        function populatePCSelectors() {
            [elements.xAxisSelect, elements.yAxisSelect, elements.zAxisSelect].forEach(select => {
                select.innerHTML = '';
                availablePCs.forEach((pc, idx) => {
                    const option = document.createElement('option');
                    option.value = pc;
                    option.textContent = pc.toUpperCase();
                    select.appendChild(option);
                });
            });
            
            if (availablePCs.length >= 1) elements.xAxisSelect.value = availablePCs[0];
            if (availablePCs.length >= 2) elements.yAxisSelect.value = availablePCs[1];
            if (availablePCs.length >= 3) elements.zAxisSelect.value = availablePCs[2];
        }
        
        function updateGroupFilters() {
            elements.groupFilters.innerHTML = '';
            Object.keys(groupColors).forEach(group => {
                const div = document.createElement('div');
                div.className = 'group-item';
                
                const checkbox = document.createElement('input');
                checkbox.type = 'checkbox';
                checkbox.checked = true;
                checkbox.dataset.group = group;
                checkbox.addEventListener('change', updatePlot);
                
                const colorBox = document.createElement('div');
                colorBox.className = 'color-box';
                colorBox.style.backgroundColor = groupColors[group];
                
                const label = document.createElement('label');
                label.textContent = group;
                
                div.appendChild(checkbox);
                div.appendChild(colorBox);
                div.appendChild(label);
                elements.groupFilters.appendChild(div);
            });
        }
        
        function updatePlot() {
            if (rawData.length === 0) return;
            
            const is3D = elements.dimensionSelect.value === '3d';
            const xAxis = elements.xAxisSelect.value;
            const yAxis = elements.yAxisSelect.value;
            const zAxis = is3D ? elements.zAxisSelect.value : null;
            
            elements.zAxisContainer.style.display = is3D ? 'block' : 'none';
            
            const visibleGroups = new Set();
            document.querySelectorAll('.group-item input[type="checkbox"]').forEach(cb => {
                if (cb.checked) visibleGroups.add(cb.dataset.group);
            });
            
            const groupedData = {};
            rawData.forEach(point => {
                if (visibleGroups.has(point.group)) {
                    if (!groupedData[point.group]) groupedData[point.group] = [];
                    groupedData[point.group].push(point);
                }
            });
            
            const traces = Object.entries(groupedData).map(([group, points]) => {
                const trace = {
                    x: points.map(p => p.pcs[xAxis]),
                    y: points.map(p => p.pcs[yAxis]),
                    text: points.map(p => p.id),
                    mode: 'markers',
                    type: is3D ? 'scatter3d' : 'scattergl',
                    name: group,
                    marker: {
                        size: 4,
                        color: groupColors[group],
                        opacity: 0.7
                    }
                };
                
                if (is3D) {
                    trace.z = points.map(p => p.pcs[zAxis]);
                }
                
                return trace;
            });
            
            const layout = {
                margin: { t: 20, l: 50, r: 20, b: 50 },
                xaxis: { title: xAxis.toUpperCase() },
                yaxis: { title: yAxis.toUpperCase() },
                hovermode: 'closest',
                dragmode: 'zoom',
                autosize: true
            };
            
            if (is3D) {
                layout.scene = {
                    xaxis: { title: xAxis.toUpperCase() },
                    yaxis: { title: yAxis.toUpperCase() },
                    zaxis: { title: zAxis.toUpperCase() }
                };
                delete layout.xaxis;
                delete layout.yaxis;
            }
            
            Plotly.newPlot(elements.plot, traces, layout, { responsive: true });
        }
        
        function setStatus(msg) {
            elements.loadStatus.textContent = msg;
        }
        
        init();
    })();
    </script>
</body>
</html>
